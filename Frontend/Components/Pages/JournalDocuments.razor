@page "/journal/{journalId:int}/documents"

@inherits CRUDPageBase

@using Contracts.Journal.Files
@using Frontend.Components.Buttons
@using Frontend.Components.Utils
@using Frontend.Services
@using Microsoft.AspNetCore.Components.QuickGrid

@inject HttpClient HttpClient
@inject IJSRuntime JSRuntime
@inject APIService APIService
@inject AppState AppState

<PageTitle>Документы</PageTitle>

@if (_documents == null)
{
    <p><em>Загрузка...</em></p>
}
else
{
    @if (_canCRUD)
    {
        <UploadButton @onclick="OpenUploadModal" AdditionalClasses="mb-3">Загрузить</UploadButton>
    }
    <Modal IsVisible="_isUploadModalVisible" OnClose="CloseUploadModal">
        <div class="row">
            <div class="col-md-12">
                <div class="mb-3">
                    <InputFile OnChange="HandleFileSelected" class="form-control" />
                </div>
                <UploadButton @onclick="UploadFile" IsDisabled="!_canUpload">Загрузить</UploadButton>
            </div>
        </div>
    </Modal>

    <QuickGrid Items="_documents" class="table">
        <PropertyColumn Property="@(l => l)" Title="Имя" Sortable="true" class="align-middle" />
        <TemplateColumn class="text-end">
            <DownloadButton @onclick="async () => await DownloadFile(context)" AdditionalClasses="me-1" StopPropagation="true" />
            @if (_canCRUD)
            {
                <DeleteButton @onclick="async () => await DeleteFile(context)" StopPropagation="true" />
            }
        </TemplateColumn>
    </QuickGrid>

    <AlertBottom IsVisible="_isServerErrorAlertVisible" OnClose="CloseServerErrorAlert">@_errorMessage</AlertBottom>
}

@code {
    [Parameter]
    public int JournalId { get; set; }

    private IQueryable<string>? _documents;

    private bool _isUploadModalVisible = false;

    private bool _canCRUD => AppState.CanCreateEntities;

    private const int _maxFileSizeMB = 10;
    private const long _maxFileSize = _maxFileSizeMB * 1024 * 1024; //10MB

    private IBrowserFile? _selectedFile;
    private bool _canUpload => _selectedFile != null;

    private List<string> _allowedExtensions = new() { ".doc", ".docx", ".xls", ".xlsx", ".txt" };

    protected override async Task OnInitializedAsync()
    {
        var hasAccess = await APIService.GetFromJsonAsync<bool>("api/journal/verifyaccess/" + JournalId);
        if (!hasAccess)
        {
            NavigateToAccessDeniedPage();
            return;
        }

        await FetchDocuments();
    }

    private async Task FetchDocuments()
    {
        var documents = await HttpClient.GetFromJsonAsync<List<string>>("api/journal/documents/" + JournalId.ToString());
        if (documents != null) _documents = documents.AsQueryable();
    }

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;
    }

    private async Task UploadFile()
    {
        if (_selectedFile == null || _selectedFile.Size == 0) return;
        var fileExtension = Path.GetExtension(_selectedFile.Name).ToLower();
        if (!_allowedExtensions.Contains(fileExtension))
        {
            ShowServerErrorAlert($"Ошибка: Неподдерживаемый формат файла. Разрешены только: {string.Join(", ", _allowedExtensions)}");
            return;
        }
        try
        {
            using var fileStream = _selectedFile.OpenReadStream(maxAllowedSize: _maxFileSize);
            using var formContent = new MultipartFormDataContent {
                { new StreamContent(fileStream), "fileToUpload", _selectedFile.Name }
            };

            var response = await HttpClient.PostAsync("api/journal/uploaddocument/" + JournalId, formContent);

            if (response.IsSuccessStatusCode)
            {
                await FetchDocuments();
            }
            else
            {
                ShowServerErrorAlert($"Ошибка: {response.ReasonPhrase}");
            }
        }
        catch (IOException)
        {
            ShowServerErrorAlert($"Ошибка: Размер файла превышает {_maxFileSizeMB} МБ");
        }
        catch (Exception ex)
        {
            ShowServerErrorAlert($"Ошибка: {ex.Message}");
        }
    }

    private async Task DownloadFile(string fileName)
    {
        await JSRuntime.InvokeVoidAsync("downloadFile", new DownloadFileRequest(JournalId, fileName));
    }

    private async Task DeleteFile(string fileName)
    {
        var response = await HttpClient.PutAsJsonAsync("api/journal/deletedocument", new DeleteFileRequest(JournalId, fileName));

        if (response.IsSuccessStatusCode)
        {
            _documents = _documents!.Where(l => l != fileName);
        }
        else
        {
            var errorMessage = await response.Content.ReadAsStringAsync();
            errorMessage = errorMessage.Split('\n').FirstOrDefault();
            ShowServerErrorAlert(errorMessage);
        }
    }

    private void OpenUploadModal()
    {
        _selectedFile = null;
        _isUploadModalVisible = true;
    }

    private void CloseUploadModal()
    {
        _selectedFile = null;
        _isUploadModalVisible = false;
    }
}
